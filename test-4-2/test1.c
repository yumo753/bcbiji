#define _CRT_SECURE_NO_WARNINGS 1

//// 二维数组
//#include <stdio.h>
//int main()
//{
//	int a[3][4] = { 0 };
//	printf("%d\n", sizeof(a));// 48 
//	// 3*4*4(int类型)
//
//
//	printf("%d\n", sizeof(a[0][0])); // 4 
//	// 第一行第一个元素
//
//	printf("%d\n", sizeof(a[0])); // 16
//	// a[0]，二维数组中的首元素，将二维数组看成一维数组，首元素就是其中的二维数组中的第一个一维数组
//	// sizeof计算的就是 二维数组中的第一个一维数组 所占空间的大小
//
//	printf("%d\n", sizeof(a[0] + 1)); // 8 
//	// 此时a[0]表示二维数组中第一个一维数组的地址， + 1 = 第一个一维数组中第二个元素的地址，地址
//
//
//	printf("%d\n", sizeof(*(a[0] + 1)));// 4 
//	// 第一个一维数组中第二个元素大小，
//
//
//	printf("%d\n", sizeof(a + 1)); // 8 
//	// a是二维数组的数组名，没有sizeof(数组名)，也没有&(数组名)，所以a是首元素地址
//	// a 此时表示二维数组的首元素：第一行数组的地址，步长为第一行数组的长度，
//	// +1 = 第二行数组的地址，步长还是第一行数组的长度，地址 4/8
//
//	printf("%d\n", sizeof(*(a + 1))); // 16
//	// sizeof计算的是 第二行数组 的大小
//
//
//	printf("%d\n", sizeof(&a[0] + 1)); // 8
//	// 此时a[0]表示二维数组中第一个一维数组的地址，取地址+1，得到第二个一维数组的地址，还是地址 4(32)/8(64)
//
//
//	printf("%d\n", sizeof(*(&a[0] + 1))); // 16
//	// &a[0], 是指向二维数组中的第一个一维度数组地址，步长为一个二维数组中一维数组的长度
//	// &a[0] + 1 即指向二维数组中的第二个一维度数组地址，步长为一个二维数组中一维数组的长度
//	// 对&a[0] + 1解引用便得到了，第二行一维数组，4*4=16
//
//
//	printf("%d\n", sizeof(*a)); // 16
//	// a是二维数组的数组名，没有sizeof(数组名)，也没有&(数组名)，所以a是首元素地址
//	// a 此时表示二维数组的首元素：第一行数组的地址，步长为第一行数组的长度
//	// 计算的是第一行数组的长度 4*4 = 16
//
//	printf("%d\n", sizeof(a[3])); // 16
//	// sizeof表达式不会真的去计算()内的表达式，只会根据类型去判断大小
//	// sizeof不会真的去访问第四行，而是回把他当作一个一维数组去计算
//	return 0;
//}


//#include <stdio.h>
//int main()
//{
//	int a[5] = { 1, 2, 3, 4, 5 };
//	int* ptr = (int*)(&a + 1);
//	// &a取出的整个数组的地址， &a+1,跳过整个数组后的地址，类型为数组指针，步长为数组a的长度
//	// 将&a+1的类型从数组指针强制转换为整型指针，步长为int类型长度
//
//	printf("%d, %d\n", *(a + 1), *(ptr - 1)); // 2, 5
//	// *(a + 1) a表示首元素地址，+1，第二个元素地址，解引用得到第二个元素
//	// *(ptr - 1) ptr表示跳过数组后的地址，类型为整型指针，步长为int类型长度
//	// ptr - 1 数组中最后一个元素的地址，解引用得到最后一个元素
//
//	return 0;
//}

//#include <stdio.h>
//
//struct Test 
//{
//	int Num;
//	char* pcName;
//	short sDate;
//	char cha[2];
//	short Sba[4];
//}*p;
//
//// 假设p 的值为0x100000，下面表达式的值分别是多少(32位平台)
//// 已知结构体Test类型的变量大小是20个字节
//
//int main()
//{
//	p = (struct Test*)0x100000;
//	printf("%p\n", p + 0x1); // 0x00100014
//	// p + 0x1 = p + 1 = p + 步长(步长位类型大小-20字节)
//	// 20(10) -> 14(16) 所以结果是0x00100014
//
//	printf("%p\n", (unsigned long)p + 0x1); //0x00100001
//	// p强制转换为 unsigned long 类型，无符号长整型
//	// 0x100000-> 整数 +1 = 0x100001
//
//	printf("%p\n", (unsigned int*)p + 0x1); // 0x00100004
//	// p强制转换为 unsigned int 类型，无符号整型指针
//	// 指针 + 1(步长为类型大小-4字节) = 0x100004
//	return 0;
//}


//#include <stdio.h>
//int main()
//{
//	int a[4] = { 1, 2, 3, 4 };
//	int* ptr1 = (int*)(&a + 1);
//	int* ptr2 = (int*)((int)a + 1);
// 
//	printf("%x\n", ptr1[-1]); // 4
//	
// // ptr1[-1] = *(ptr1 - 1), ptr1是跳过数组a后的地址，-1就得到数组a的最后一个元素的地址
//
//	printf("%x\n", *ptr2); // *(a[0]的地址值+1)=未知//报错
//	// a表示首元素地址，(int)a 将地址值强制类型转换为int类型-整型，整型+1，在将他转换为int*类型
//		// ===============================================
//		//	11223344  | 11223348  | 1122334C  | 11223350
//		// ================================================
//		// 44|45|46|47|48|49|4A|4B|4C|4D|4E|4F|50|51|52|53|
//		// ================================================
//		//	1-a[0]	  |  2-a[1]   |  3-a[2]   |  4-a[3]
//		// ================================================
//		// 假设首元素地址0x11223344，(int)0x11223344 + 1 = 0x11223345,
//		// 45 - 48是啥，咋也不知道，题目要，%x以16进制数形式输出整型，由于地址在内存中存放的方式为小端
//		// 所以输出结果是 45332211 - 适用于vs2013
//		//						   - vs2022会出现越界访问的报错
//		// 
//
//	// %x-以16进制数形式输出整型
//
//	return 0;
//}


//#include <stdio.h>
//int main()
//{
//	int a[3][2] = { (0, 1), (2, 3), (4, 5) };
//	// { (0, 1), (2, 3), (4, 5) } 逗号表达式，逗号表达式的值为最后一个表达式的结果
//	// 所以 a实际上是：{ 1, 3, 5, 0, 0, 0} -> { (1, 3), (5, 0), (0, 0) };
//	
//	int* p;
//	// p为整型指针，可访问的空间只有4个字节
//	
//	p = a[0];
//	// a[0]为第一行数组的地址，大小为8个字节，但p为整型指针，可访问的空间只有4个字节
//	// 把第一行数组的第一个元素的地址交给p
//	
//	printf("%d", p[0]);// 1
//	// p[0] = *(p + 0)，访问第一行数组的第一个元素, 结果是1
//	return 0;
//}


#include <stdio.h>
int main()
{
	int a[5][5];
	int(*p)[4];       
	// 此时p的步长是4
	p = a;

	printf("%p, %d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
	// p[4][2]
	// = *(*(p+4)+2)
	// *(p+4)的步长是1

	// &p[4][2] - &a[4][2] = -4

	// -4
	// 10000000-00000000-00000000-00000100
	// 11111111-11111111-11111111-11111011
	// 11111111-11111111-11111111-11111100
	// FF-FF-FF-FC
	// %p 输出结果 FF-FF-FF-FC（32位）

	return 0;
}